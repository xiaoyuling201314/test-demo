<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd">
	<!-- Annotation Config -->
	<context:annotation-config />
	
	<!-- <context:property-placeholder file-encoding="UTF-8" location="classpath:sysconfig.properties,classpath:jdbc.properties" /> -->
	<bean id="propertyConfigurer" class="com.dayuan.common.EncryPropertryConfigurer" >
		<property name="locations">
			<list>
				<value>classpath:sysconfig.properties</value>
				<!--<value>classpath:payinfo.properties</value>-->
				<value>classpath:jdbc.properties</value>
			</list>
		</property>
		<property name="fileEncoding">
			<value>utf-8</value>
		</property>
	</bean>

	<!-- Spring 线程池配置 -->
	<bean id="threadPoolTaskExecutor"  class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">
		<!-- 核心线程数，默认为1 -->
		<property name="corePoolSize" value="1" />
		<!-- 最大线程数，默认为Integer.MAX_VALUE -->
		<property name="maxPoolSize" value="10" />
		<!-- 队列最大长度，一般需要设置值>=notifyScheduledMainExecutor.maxNum；默认为Integer.MAX_VALUE -->
		<property name="queueCapacity" value="2000" />
		<!-- 线程池维护线程所允许的空闲时间，默认为60s -->
		<property name="keepAliveSeconds" value="60" />
		<!-- 线程池对拒绝任务（无线程可用）的处理策略，目前只支持AbortPolicy、CallerRunsPolicy；默认为后者 -->
		<property name="rejectedExecutionHandler">
			<!-- AbortPolicy:直接抛出java.util.concurrent.RejectedExecutionException异常 -->
			<!-- CallerRunsPolicy:主线程直接执行该任务，执行完之后尝试添加下一个任务到线程池中，可以有效降低向线程池内添加任务的速度 -->
			<!-- DiscardOldestPolicy:抛弃旧的任务、暂不支持；会导致被丢弃的任务无法再次被执行 -->
			<!-- DiscardPolicy:抛弃当前任务、暂不支持；会导致被丢弃的任务无法再次被执行 -->
			<bean class="java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy" />
		</property>
	</bean>

	<!-- 扫描Service -->
	<context:component-scan base-package="com.*.service,com.*.service.*.impl,com.*.*.service,com.*.*.task,com.dayuan3.*.service,com.dayuan3.*.service.impl" />
	<bean class="com.dayuan.util.ContextHolderUtils"></bean>

	<!-- ***************druid 配置数据源************** -->
	<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close">
		<!-- 基本属性 url、user、password -->
		<property name="url" value="${jdbc.url1}" />
		<property name="username" value="${jdbc.username1}" />
		<property name="password" value="${jdbc.password1}" />
		
		<!-- 配置初始化大小、最小、最大 -->
		<property name="initialSize" value="${jdbc.initialSize}" />
		<property name="minIdle" value="${jdbc.minIdle}" />
		<property name="maxActive" value="${jdbc.maxActive}" />

		<!-- 配置获取连接等待超时的时间 -->
		<property name="maxWait" value="${jdbc.maxWait}" />

		<!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 -->
		<property name="timeBetweenEvictionRunsMillis" value="${jdbc.timeBetweenEvictionRunsMillis}" />

		<!-- 配置一个连接在池中最小生存的时间，单位是毫秒 -->
		<property name="minEvictableIdleTimeMillis" value="${jdbc.minEvictableIdleTimeMillis}" />
		<property name="validationQuery" value="${jdbc.validationQuery}" />
		<property name="testWhileIdle" value="${jdbc.testWhileIdle}" />
		<property name="testOnBorrow" value="${jdbc.testOnBorrow}" />
		<property name="testOnReturn" value="${jdbc.testOnReturn}" />

		<!-- 打开PSCache，并且指定每个连接上PSCache的大小 -->
		<property name="poolPreparedStatements" value="${jdbc.poolPreparedStatements}" />
		<property name="maxPoolPreparedStatementPerConnectionSize" value="${jdbc.maxPoolPreparedStatementPerConnectionSize}" />

		<!-- 开启Druid的监控统计-->
		<property name="filters" value="${jdbc.filters}" />
		
	</bean>
	
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate" >
		<property name="dataSource" ref="dataSource"></property>
	</bean>

	<!-- ***************事务配置************** -->
<!-- 	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource" />
	</bean>

	<aop:config>
		<aop:advisor pointcut="execution(* com.dayuan.service.*.*(..))" advice-ref="txAdvice" />
	</aop:config>

	<tx:advice id="txAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<tx:method name="get*" read-only="true" />
			<tx:method name="query*" read-only="true" />
			<tx:method name="find*" read-only="true" />
			<tx:method name="load*" read-only="true" />
			<tx:method name="datagrid*" read-only="true" />
			<tx:method name="select*" read-only="true" />
			<tx:method name="*" propagation="REQUIRED" rollback-for="Exception" />
		</tx:attributes>
	</tx:advice> -->
	
	<!-- 启用注解器、映射器 -->
    <mvc:annotation-driven/>
	
	<!-- 事务管理器  -->
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"> 
	    <property name="dataSource" ref="dataSource" />
	</bean>

	
	<!-- 事务注解驱动，标注@Transactional的类和方法将具有事务性 --> 
	<tx:annotation-driven transaction-manager="transactionManager" />

	<!-- MyBatis Sql -->
<!--	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">-->
<!--		<property name="dataSource" ref="dataSource" />-->
<!--		&lt;!&ndash; 自动扫描mapping.xml文件 &ndash;&gt;-->
<!--		&lt;!&ndash;数组方式&ndash;&gt;-->
<!--		<property name="mapperLocations">-->
<!--			<array>-->
<!--				<value>classpath:com/dayuan/**/mybatis/**/*.xml</value>-->
<!--				<value>classpath:com/dayuan3/**/mybatis/**/*.xml</value>-->
<!--			</array>-->
<!--		</property>-->
<!--		<property name="configLocation" value="classpath:mybatis-config.xml" />-->
<!--	</bean>-->

	<!-- 扫描mapper.java -->
<!--	<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">-->
<!--		<property name="basePackage" value="com.dayuan.mapper,com.dayuan.*.mapper,com.dayuan3.*.mapper,com.dayuan4.*.mapper" />-->
<!--		<property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" />-->
<!--	</bean>-->

	<bean id="sqlSessionFactory" class="com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource"/>
		<property name="mapperLocations">
			<array>
				<value>classpath:com/dayuan/**/mybatis/**/*.xml</value>
				<value>classpath:com/dayuan3/**/mybatis/**/*.xml</value>
			</array>
		</property>
		<property name="configLocation" value="classpath:mybatis-config.xml" />

		<property name="plugins">
			<array>
				<ref bean="mybatisPlusInterceptor"/>
			</array>
		</property>

	</bean>
	<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<property name="basePackage" value="com.baomidou.mybatisplus.samples.quickstart.mapper,com.dayuan.mapper,com.dayuan.*.mapper,com.dayuan3.*.mapper,com.dayuan4.*.mapper"/>
	</bean>

	<!-- 分页插件 -->
	<bean id="mybatisPlusInterceptor" class="com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor">
		<property name="interceptors">
			<list>
				<ref bean="paginationInnerInterceptor"/>
			</list>
		</property>
	</bean>
	<bean id="paginationInnerInterceptor" class="com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor">
		<!-- 对于单一数据库类型来说,都建议配置该值,避免每次分页都去抓取数据库类型 -->
		<constructor-arg name="dbType" value="MYSQL"/>
	</bean>
</beans>

